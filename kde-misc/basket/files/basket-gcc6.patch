--- old/src/archive.cpp	2010-06-03 05:48:13.000000000 +0200
+++ new/src/archive.cpp	2016-10-15 14:31:30.452445412 +0200
@@ -54,7 +54,7 @@
 void Archive::save(BasketView *basket, bool withSubBaskets, const QString &destination)
 {
     QDir dir;
-    KProgressDialog dialog(0, i18n("Save as Basket Archive"), i18n("Saving as basket archive. Please wait..."), /*Not modal, for password dialogs!*/false);
+    KProgressDialog dialog(0, i18n("Save as Basket Archive"), i18n("Saving as basket archive. Please wait..."), /*Not modal, for password dialogs!*/ Qt::Widget);
     dialog.showCancelButton(false);
     dialog.setAutoClose(true);
     dialog.show();
diff -Naur old/src/backgroundmanager.cpp new/src/backgroundmanager.cpp
--- old/src/backgroundmanager.cpp	2010-06-03 05:48:13.000000000 +0200
+++ new/src/backgroundmanager.cpp	2016-10-15 14:31:56.372445221 +0200
@@ -258,7 +258,7 @@
 
     if (!entry) {
 ///     kDebug() << "BackgroundManager: Requested the preview of an unexisting image: " << image;
-        return false;
+        return 0;
     }
 
     // The easiest way: already computed:
diff -Naur old/src/basketview.cpp new/src/basketview.cpp
--- old/src/basketview.cpp	2010-09-26 05:57:18.000000000 +0200
+++ new/src/basketview.cpp	2016-10-15 14:55:55.412434604 +0200
@@ -3231,7 +3231,7 @@
             if (currentState == nextState && !tag->shortcut().isEmpty())
                 sequence = tag->shortcut().primary();
 
-            StateAction *sa = new StateAction(currentState, KShortcut(sequence), false);
+            StateAction *sa = new StateAction(currentState, KShortcut(sequence), &menu);
             sa->setChecked(state == currentState);
             sa->setActionGroup(emblemGroup);
             sa->setData(i);
diff -Naur old/src/formatimporter.cpp new/src/formatimporter.cpp
--- old/src/formatimporter.cpp	2010-06-03 05:48:13.000000000 +0200
+++ new/src/formatimporter.cpp	2016-10-15 14:53:47.532435547 +0200
@@ -60,7 +60,7 @@
 void FormatImporter::copyFolder(const QString &folder, const QString &newFolder)
 {
     copyFinished = false;
-    KIO::CopyJob *copyJob = KIO::copyAs(KUrl(folder), KUrl(newFolder), /*showProgressInfo=*/false);
+    KIO::CopyJob *copyJob = KIO::copyAs(KUrl(folder), KUrl(newFolder), /*showProgressInfo=*/ KIO::HideProgressInfo);
     connect(copyJob,  SIGNAL(copyingDone(KIO::Job *, KUrl, KUrl, time_t, bool, bool)),
             this, SLOT(slotCopyingDone(KIO::Job*)));
     while (!copyFinished)
@@ -70,7 +70,7 @@
 void FormatImporter::moveFolder(const QString &folder, const QString &newFolder)
 {
     copyFinished = false;
-    KIO::CopyJob *copyJob = KIO::moveAs(KUrl(folder), KUrl(newFolder), /*showProgressInfo=*/false);
+    KIO::CopyJob *copyJob = KIO::moveAs(KUrl(folder), KUrl(newFolder), /*showProgressInfo=*/KIO::HideProgressInfo);
     connect(copyJob,  SIGNAL(copyingDone(KIO::Job *, KUrl, KUrl, time_t, bool, bool)),
             this, SLOT(slotCopyingDone(KIO::Job*)));
     while (!copyFinished)
@@ -200,7 +200,7 @@
     disposition.setAttribute("mindMap",     "false");
     disposition.setAttribute("columnCount", "1");
     disposition.setAttribute("free",        "false");
-    bool isCheckList = XMLWork::trueOrFalse(XMLWork::getElementText(properties, "showCheckBoxes", false));
+    bool isCheckList = XMLWork::trueOrFalse(XMLWork::getElementText(properties, "showCheckBoxes"));
 
     // Insert all notes in a group (column): 1/ rename "items" to "group", 2/ add "notes" to root, 3/ move "group" into "notes"
     QDomElement column = XMLWork::getElement(docElem, "items");
diff -Naur old/src/htmlexporter.cpp new/src/htmlexporter.cpp
--- old/src/htmlexporter.cpp	2010-09-26 05:57:18.000000000 +0200
+++ new/src/htmlexporter.cpp	2016-10-15 14:54:59.302435018 +0200
@@ -81,7 +81,7 @@
     }
 
     // Create the progress dialog that will always be shown during the export:
-    KProgressDialog dialog(0, i18n("Export to HTML"), i18n("Exporting to HTML. Please wait..."), /*Not modal, for password dialogs!*/false);
+    KProgressDialog dialog(0, i18n("Export to HTML"), i18n("Exporting to HTML. Please wait..."), /*Not modal, for password dialogs!*/ Qt::Widget);
     dialog.showCancelButton(false);
     dialog.setAutoClose(true);
     dialog.show();
@@ -334,12 +334,12 @@
         // This is a 1px*1px transparent GIF image:
         const char blankGIF[] = {
             0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x0a, 0x00, 0x0a, 0x00,
-            0x80, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x21,
-            0xfe, 0x15, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
+            -0x80, 0x00, 0x00, -0x1, -0x1, -0x1, -0x1, -0x1, -0x1, 0x21,
+            -0x2, 0x15, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
             0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65, 0x20, 0x47,
-            0x49, 0x4d, 0x50, 0x00, 0x21, 0xf9, 0x04, 0x01, 0x0a, 0x00,
+            0x49, 0x4d, 0x50, 0x00, 0x21, -0x7, 0x04, 0x01, 0x0a, 0x00,
             0x01, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0a,
-            0x00, 0x00, 0x02, 0x08, 0x8c, 0x8f, 0xa9, 0xcb, 0xed, 0x0f,
+            0x00, 0x00, 0x02, 0x08, -0x74, -0x71, -0x57, -0x35, -0x13, 0x0f,
             0x63, 0x2b, 0x00, 0x3b
         };
         streamGIF.writeRawData(blankGIF, 74);
