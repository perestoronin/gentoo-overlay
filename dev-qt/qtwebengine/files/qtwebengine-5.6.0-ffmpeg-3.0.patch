--- old/src/3rdparty/chromium/media/filters/ffmpeg_h264_to_annex_b_bitstream_converter.cc	2016-03-03 15:48:36.000000000 +0100
+++ new/src/3rdparty/chromium/media/filters/ffmpeg_h264_to_annex_b_bitstream_converter.cc	2016-03-25 14:56:59.332811456 +0100
@@ -71,7 +71,7 @@
     configuration_processed_ = true;
 
   // At the end we must destroy the old packet.
-  av_free_packet(packet);
+  av_packet_unref(packet);
   *packet = dest_packet;  // Finally, replace the values in the input packet.
 
   return true;
--- old/src/3rdparty/chromium/media/filters/audio_file_reader.cc	2016-03-03 15:48:36.000000000 +0100
+++ new/src/3rdparty/chromium/media/filters/audio_file_reader.cc	2016-03-25 14:56:23.692811719 +0100
@@ -136,7 +136,7 @@
   while (current_frame < audio_bus->frames() && continue_decoding &&
          ReadPacket(&packet)) {
     // Make a shallow copy of packet so we can slide packet.data as frames are
-    // decoded from the packet; otherwise av_free_packet() will corrupt memory.
+    // decoded from the packet; otherwise av_packet_unref() will corrupt memory.
     AVPacket packet_temp = packet;
     do {
       // Reset frame to default values.
@@ -221,7 +221,7 @@
 
       current_frame += frames_read;
     } while (packet_temp.size > 0);
-    av_free_packet(&packet);
+    av_packet_unref(&packet);
   }
 
   // Zero any remaining frames.
@@ -261,7 +261,7 @@
          av_dup_packet(output_packet) >= 0) {
     // Skip packets from other streams.
     if (output_packet->stream_index != stream_index_) {
-      av_free_packet(output_packet);
+      av_packet_unref(output_packet);
       continue;
     }
     return true;
--- old/src/3rdparty/chromium/media/base/media_file_checker.cc	2016-03-03 15:48:36.000000000 +0100
+++ new/src/3rdparty/chromium/media/base/media_file_checker.cc	2016-03-25 14:55:35.662812073 +0100
@@ -73,7 +73,7 @@
     std::map<int, AVCodecContext*>::const_iterator it =
         stream_contexts.find(packet.stream_index);
     if (it == stream_contexts.end()) {
-      av_free_packet(&packet);
+      av_packet_unref(&packet);
       continue;
     }
     AVCodecContext* av_context = it->second;
@@ -81,7 +81,7 @@
     int frame_decoded = 0;
     if (av_context->codec_type == AVMEDIA_TYPE_AUDIO) {
       // A shallow copy of packet so we can slide packet.data as frames are
-      // decoded; otherwise av_free_packet() will corrupt memory.
+      // decoded; otherwise av_packet_unref() will corrupt memory.
       AVPacket temp_packet = packet;
       do {
         result = avcodec_decode_audio4(av_context, frame.get(), &frame_decoded,
@@ -99,7 +99,7 @@
       if (result >= 0 && frame_decoded)
         av_frame_unref(frame.get());
     }
-    av_free_packet(&packet);
+    av_packet_unref(&packet);
   } while (base::TimeTicks::Now() < deadline && read_ok && result >= 0);
 
   return read_ok && (result == AVERROR_EOF || result >= 0);
--- old/src/3rdparty/chromium/media/filters/ffmpeg_aac_bitstream_converter.cc	2016-03-03 15:48:36.000000000 +0100
+++ new/src/3rdparty/chromium/media/filters/ffmpeg_aac_bitstream_converter.cc	2016-03-25 14:54:06.822812729 +0100
@@ -19,7 +19,7 @@
     int private_stream, int channel_configuration, int originality, int home,
     int copyrighted_stream, int copyright_start, int frame_length,
     int buffer_fullness, int number_of_frames_minus_one, uint8* hdr) {
-  DCHECK_EQ(codec, CODEC_ID_AAC);
+  DCHECK_EQ(codec, AV_CODEC_ID_AAC);
 
   memset(reinterpret_cast<void *>(hdr), 0,
          FFmpegAACBitstreamConverter::kAdtsHeaderSize);
@@ -230,7 +230,7 @@
   av_packet_copy_props(&dest_packet, packet);
 
   // Release the old packet.
-  av_free_packet(packet);
+  av_packet_unref(packet);
   *packet = dest_packet;  // Finally, replace the values in the input packet.
 
   return true;
--- old/src/3rdparty/chromium/media/filters/ffmpeg_demuxer.cc	2016-03-03 15:48:36.000000000 +0100
+++ new/src/3rdparty/chromium/media/filters/ffmpeg_demuxer.cc	2016-03-25 14:51:52.252813722 +0100
@@ -691,7 +691,7 @@
   // this does not increase the amount of data downloaded.  The default value
   // is 5 AV_TIME_BASE units (1 second each), which prevents some oddly muxed
   // streams from being detected properly; this value was chosen arbitrarily.
-  format_context->max_analyze_duration2 = 60 * AV_TIME_BASE;
+  format_context->max_analyze_duration = 60 * AV_TIME_BASE;
 
   // Open the AVFormatContext using our glue layer.
   CHECK(blocking_thread_.Start());
--- old/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.h	2016-03-03 15:48:36.000000000 +0100
+++ new/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.h	2016-03-25 14:53:05.252813183 +0100
@@ -61,7 +61,7 @@
 
 inline void ScopedPtrAVFreePacket::operator()(void* x) const {
   AVPacket* packet = static_cast<AVPacket*>(x);
-  av_free_packet(packet);
+  av_packet_unref(packet);
   delete packet;
 }
 
@@ -123,10 +123,10 @@
 
 // Converts FFmpeg's pixel formats to its corresponding supported video format.
 MEDIA_EXPORT VideoFrame::Format PixelFormatToVideoFormat(
-    PixelFormat pixel_format);
+    AVPixelFormat pixel_format);
 
 // Converts video formats to its corresponding FFmpeg's pixel formats.
-PixelFormat VideoFormatToPixelFormat(VideoFrame::Format video_format);
+AVPixelFormat VideoFormatToPixelFormat(VideoFrame::Format video_format);
 
 // Convert FFmpeg UTC representation (YYYY-MM-DD HH:MM:SS) to base::Time.
 // Returns true and sets |*out| if |date_utc| contains a valid
--- old/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc	2016-03-03 15:48:36.000000000 +0100
+++ new/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc	2016-03-25 14:49:38.682814707 +0100
@@ -532,41 +532,41 @@
   }
 }
 
-VideoFrame::Format PixelFormatToVideoFormat(PixelFormat pixel_format) {
+VideoFrame::Format PixelFormatToVideoFormat(AVPixelFormat pixel_format) {
   // The YUVJ alternatives are FFmpeg's (deprecated, but still in use) way to
   // specify a pixel format and full range color combination
   switch (pixel_format) {
-    case PIX_FMT_YUV422P:
-    case PIX_FMT_YUVJ422P:
+    case AV_PIX_FMT_YUV422P:
+    case AV_PIX_FMT_YUVJ422P:
       return VideoFrame::YV16;
-    case PIX_FMT_YUV444P:
-    case PIX_FMT_YUVJ444P:
+    case AV_PIX_FMT_YUV444P:
+    case AV_PIX_FMT_YUVJ444P:
       return VideoFrame::YV24;
-    case PIX_FMT_YUV420P:
-    case PIX_FMT_YUVJ420P:
+    case AV_PIX_FMT_YUV420P:
+    case AV_PIX_FMT_YUVJ420P:
       return VideoFrame::YV12;
-    case PIX_FMT_YUVA420P:
+    case AV_PIX_FMT_YUVA420P:
       return VideoFrame::YV12A;
     default:
-      DVLOG(1) << "Unsupported PixelFormat: " << pixel_format;
+      DVLOG(1) << "Unsupported AVPixelFormat: " << pixel_format;
   }
   return VideoFrame::UNKNOWN;
 }
 
-PixelFormat VideoFormatToPixelFormat(VideoFrame::Format video_format) {
+AVPixelFormat VideoFormatToPixelFormat(VideoFrame::Format video_format) {
   switch (video_format) {
     case VideoFrame::YV16:
-      return PIX_FMT_YUV422P;
+      return AV_PIX_FMT_YUV422P;
     case VideoFrame::YV12:
-      return PIX_FMT_YUV420P;
+      return AV_PIX_FMT_YUV420P;
     case VideoFrame::YV12A:
-      return PIX_FMT_YUVA420P;
+      return AV_PIX_FMT_YUVA420P;
     case VideoFrame::YV24:
-      return PIX_FMT_YUV444P;
+      return AV_PIX_FMT_YUV444P;
     default:
       DVLOG(1) << "Unsupported VideoFrame::Format: " << video_format;
   }
-  return PIX_FMT_NONE;
+  return AV_PIX_FMT_NONE;
 }
 
 bool FFmpegUTCDateToTime(const char* date_utc, base::Time* out) {
