--- a/third_party/gpus/cuda_configure.bzl	2022-01-06 11:56:45.200352371 +0100
+++ b/third_party/gpus/cuda_configure.bzl	2022-01-06 11:58:47.021539114 +0100
@@ -4,6 +4,7 @@

   * `TF_NEED_CUDA`: Whether to enable building with CUDA.
   * `GCC_HOST_COMPILER_PATH`: The GCC host compiler path
+  * `CUDA_HOST_COMPILER_PATH`: The CUDA host compiler path
   * `TF_CUDA_CLANG`: Whether to use clang as a cuda compiler.
   * `CLANG_CUDA_COMPILER_PATH`: The clang compiler path that will be used for
     both host and device code compilation if TF_CUDA_CLANG is 1.
@@ -54,6 +55,7 @@
 )

 _GCC_HOST_COMPILER_PATH = "GCC_HOST_COMPILER_PATH"
+_CUDA_HOST_COMPILER_PATH = "CUDA_HOST_COMPILER_PATH"
 _GCC_HOST_COMPILER_PREFIX = "GCC_HOST_COMPILER_PREFIX"
 _CLANG_CUDA_COMPILER_PATH = "CLANG_CUDA_COMPILER_PATH"
 _TF_SYSROOT = "TF_SYSROOT"
@@ -210,7 +212,7 @@
 # TODO(dzc): Once these functions have been factored out of Bazel's
 # cc_configure.bzl, load them from @bazel_tools instead.
 # BEGIN cc_configure common functions.
-def find_cc(repository_ctx):
+def find_cc(repository_ctx, cuda_host_compiler):
     """Find the C++ compiler."""
     if is_windows(repository_ctx):
         return _get_msvc_compiler(repository_ctx)
@@ -220,6 +222,9 @@
         cc_path_envvar = _CLANG_CUDA_COMPILER_PATH
         if _flag_enabled(repository_ctx, _TF_DOWNLOAD_CLANG):
             return "extra_tools/bin/clang"
+    elif cuda_host_compiler:
+        target_cc_name = "gcc"
+        cc_path_envvar = _CUDA_HOST_COMPILER_PATH
     else:
         target_cc_name = "gcc"
         cc_path_envvar = _GCC_HOST_COMPILER_PATH
@@ -1176,7 +1181,7 @@
         download_clang(repository_ctx, "crosstool/extra_tools")

     # Set up crosstool/
-    cc = find_cc(repository_ctx)
+    cc = find_cc(repository_ctx, False)
     cc_fullpath = cc if not should_download_clang else "crosstool/" + cc

     host_compiler_includes = get_cxx_inc_directories(
@@ -1184,6 +1189,16 @@
         cc_fullpath,
         tf_sysroot,
     )
+
+    cuda_cc = find_cc(repository_ctx, True)
+    cuda_cc_fullpath = cuda_cc if not should_download_clang else "crosstool/" + cc
+
+    cuda_host_compiler_includes = get_cxx_inc_directories(
+        repository_ctx,
+        cuda_cc_fullpath,
+        tf_sysroot,
+    )
+
     cuda_defines = {}
     cuda_defines["%{builtin_sysroot}"] = tf_sysroot
     cuda_defines["%{cuda_toolkit_path}"] = ""
@@ -1220,7 +1235,7 @@
         # switch it off for now.
         "-Wno-invalid-partial-specialization"
     """
-        cuda_defines["%{cxx_builtin_include_directories}"] = to_list_of_strings(host_compiler_includes)
+        cuda_defines["%{cxx_builtin_include_directories}"] = to_list_of_strings(cuda_host_compiler_includes + host_compiler_includes)
         cuda_defines["%{compiler_deps}"] = ":empty"
         cuda_defines["%{win_compiler_deps}"] = ":empty"
         repository_ctx.file(
@@ -1236,7 +1251,7 @@
         # search them; we cannot work around that, so we add the relevant cuda
         # system paths to the allowed compiler specific include paths.
         cuda_defines["%{cxx_builtin_include_directories}"] = to_list_of_strings(
-            host_compiler_includes + _cuda_include_path(
+            cuda_host_compiler_includes + host_compiler_includes + _cuda_include_path(
                 repository_ctx,
                 cuda_config,
             ) + [cupti_header_dir, cudnn_header_dir],
@@ -1258,7 +1273,7 @@
             "%{cpu_compiler}": str(cc),
             "%{cuda_version}": cuda_config.cuda_version,
             "%{nvcc_path}": nvcc_path,
-            "%{gcc_host_compiler_path}": str(cc),
+            "%{gcc_host_compiler_path}": str(cuda_cc),
             "%{nvcc_tmp_dir}": _get_nvcc_tmp_dir_for_windows(repository_ctx),
         }
         repository_ctx.template(
@@ -1420,6 +1435,7 @@
 _ENVIRONS = [
     _GCC_HOST_COMPILER_PATH,
     _GCC_HOST_COMPILER_PREFIX,
+    _CUDA_HOST_COMPILER_PATH,
     _CLANG_CUDA_COMPILER_PATH,
     "TF_NEED_CUDA",
     "TF_CUDA_CLANG",
